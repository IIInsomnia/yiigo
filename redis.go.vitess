package yiigo

import (
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/fatih/color"
	"github.com/gomodule/redigo/redis"
	toml "github.com/pelletier/go-toml"
	"github.com/youtube/vitess/go/pools"
	"golang.org/x/net/context"
)

type redisConf struct {
	Name          string `toml:"name"`
	Host          string `toml:"host"`
	Port          int    `toml:"port"`
	Password      string `toml:"password"`
	Database      int    `toml:"database"`
	ConnTimeout   int    `toml:"connTimeout"`
	ReadTimeout   int    `toml:"readTimeout"`
	WriteTimeout  int    `toml:"writeTimeout"`
	MinActiveConn int    `toml:"minActiveConn"`
	MaxActiveConn int    `toml:"maxActiveConn"`
	IdleTimeout   int    `toml:"idleTimeout"`
}

// redis pool of redigo

// RedisConn redis connection resource
type RedisConn struct {
	redis.Conn
}

// Close close connection resorce
func (r RedisConn) Close() {
	r.Conn.Close()
}

// RedisPoolResource redis pool resource
type RedisPoolResource struct {
	pool   *pools.ResourcePool
	config *redisConf
	mutex sync.Mutex
}

func (r *RedisPoolResource) dial() (redis.Conn, error) {
	dsn := fmt.Sprintf("%s:%d", r.config.Host, r.config.Port)

	dialOptions := []redis.DialOption{
		redis.DialPassword(r.config.Password),
		redis.DialDatabase(r.config.Database),
		redis.DialConnectTimeout(time.Duration(r.config.ConnTimeout) * time.Second),
		redis.DialReadTimeout(time.Duration(r.config.ReadTimeout) * time.Second),
		redis.DialWriteTimeout(time.Duration(r.config.WriteTimeout) * time.Second),
	}

	conn, err := redis.Dial("tcp", dsn, dialOptions...)

	return conn, err
}

func (r *RedisPoolResource) initPool() {
	r.mutex.Lock()
	defer r.mutex.Unlock()

	if r.pool != nil && !r.pool.IsClosed() {
		return
	}

	df := func() (pools.Resource, error) {
		conn, err := r.dial()

		if err != nil {
			return nil, err
		}

		return RedisConn{conn}, nil
	}

	r.pool = pools.NewResourcePool(df, r.config.MinActiveConn, r.config.MaxActiveConn, time.Duration(r.config.IdleTimeout)*time.Second)
}

// Get get a connection resource from the pool.
func (r *RedisPoolResource) Get() (RedisConn, error) {
	if r.pool.IsClosed() {
		r.initPool()
	}

	ctx := context.TODO()
	resource, err := r.pool.Get(ctx)

	if err != nil {
		return RedisConn{}, err
	}

	rc := resource.(RedisConn)

	// if rc is error, close and reconnect
	if err = rc.Err(); err != nil {
		conn, err := r.dial()

		if err != nil {
			r.pool.Put(rc)

			return rc, err
		}

		rc.Close()

		return RedisConn{conn}, nil
	}

	return rc, nil
}

// Put returns a connection resource to the pool.
func (r *RedisPoolResource) Put(rc RedisConn) {
	r.pool.Put(rc)
}

var (
	// RedisPool default connection pool
	RedisPool *RedisPoolResource
	redisMap  sync.Map
)

func initRedis() error {
	result := Env.Get("redis")

	if result == nil {
		color.Blue("[yiigo] no redis configured")

		return nil
	}

	switch node := result.(type) {
	case *toml.Tree:
		conf := &redisConf{}
		err := node.Unmarshal(conf)

		if err != nil {
			return err
		}

		initSingleRedis(conf)
	case []*toml.Tree:
		conf := make([]*redisConf, 0, len(node))

		for _, v := range node {
			c := &redisConf{}
			err := v.Unmarshal(c)

			if err != nil {
				return err
			}

			conf = append(conf, c)
		}

		initMultiRedis(conf)
	default:
		return errors.New("yiigo: invalid redis config")
	}

	return nil
}

func initSingleRedis(conf *redisConf) {
	RedisPool = &RedisPoolResource{config: conf}
	RedisPool.initPool()

	redisMap.Store("default", RedisPool)
}

func initMultiRedis(conf []*redisConf) {
	for _, v := range conf {
		poolResource := &RedisPoolResource{config: v}
		poolResource.initPool()

		redisMap.Store(v.Name, poolResource)
	}

	if v, ok := redisMap.Load("default"); ok {
		RedisPool = v.(*RedisPoolResource)
	}
}

// RedisConnPool returns a redis pool.
func RedisConnPool(conn ...string) (*RedisPoolResource, error) {
	schema := "default"

	if len(conn) > 0 {
		schema = conn[0]
	}

	v, ok := redisMap.Load(schema)

	if !ok {
		return nil, fmt.Errorf("yiigo: redis.%s is not connected", schema)
	}

	return v.(*RedisPoolResource), nil
}
