package yiigo

import (
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"sync"
	"time"

	ini "gopkg.in/ini.v1"

	"github.com/garyburd/redigo/redis"
	"github.com/youtube/vitess/go/pools"
	"golang.org/x/net/context"
)

// redis pool of redigo

// RedisPoolResource redis pool resource
type RedisPoolResource struct {
	name string
	pool *pools.ResourcePool
	mux  sync.Mutex
}

// RedisConn redis connection resource
type RedisConn struct {
	redis.Conn
}

var (
	// RedisPool default connection pool
	RedisPool *RedisPoolResource
	redisMap  sync.Map
)

// Close close connection resorce
func (r RedisConn) Close() {
	r.Conn.Close()
}

func initRedis() {
	sections := childSections("redis")

	if len(sections) > 0 {
		initMultiRedis(sections)
		return
	}

	initSingleRedis()
}

func initSingleRedis() {
	RedisPool = &RedisPoolResource{name: "redis"}
	RedisPool.dial()
}

func initMultiRedis(sections []*ini.Section) {
	for _, v := range sections {
		pool := &RedisPoolResource{name: v.Name()}
		pool.dial()

		redisMap.Store(v.Name(), pool)
	}

	if v, ok := redisMap.Load("redis.default"); ok {
		RedisPool = v.(*RedisPoolResource)
	}
}

// RedisConnPool get an redis pool
func RedisConnPool(conn ...string) (*RedisPoolResource, error) {
	c := "default"

	if len(conn) > 0 {
		c = conn[0]
	}

	schema := fmt.Sprintf("redis.%s", c)

	v, ok := redisMap.Load(schema)

	if !ok {
		return nil, fmt.Errorf("redis %s is not connected", schema)
	}

	return v.(*RedisPoolResource), nil
}

func (r *RedisPoolResource) dial() {
	r.mux.Lock()
	defer r.mux.Unlock()

	if r.pool != nil {
		return
	}

	host := EnvString(r.name, "host", "localhost")
	port := EnvInt(r.name, "port", 6379)
	password := EnvString(r.name, "password", "")
	database := EnvInt(r.name, "database", 0)
	connTimeout := EnvInt(r.name, "connTimeout", 1000)
	readTimeout := EnvInt(r.name, "readTimeout", 1000)
	writeTimeout := EnvInt(r.name, "writeTimeout", 1000)
	minActiveConn := EnvInt(r.name, "poolMinActive", 10)
	maxActiveConn := EnvInt(r.name, "poolMaxActive", 20)
	idleTimeout := EnvInt(r.name, "poolIdleTimeout", 60000)

	df := func() (pools.Resource, error) {
		dsn := fmt.Sprintf("%s:%d", host, port)

		dialOptions := []redis.DialOption{
			redis.DialPassword(password),
			redis.DialDatabase(database),
			redis.DialConnectTimeout(time.Duration(connTimeout) * time.Millisecond),
			redis.DialReadTimeout(time.Duration(readTimeout) * time.Millisecond),
			redis.DialWriteTimeout(time.Duration(writeTimeout) * time.Millisecond),
		}

		conn, err := redis.Dial("tcp", dsn, dialOptions...)

		if err != nil {
			return nil, err
		}

		return RedisConn{conn}, nil
	}

	r.pool = pools.NewResourcePool(df, minActiveConn, maxActiveConn, time.Duration(idleTimeout) * time.Millisecond)
}

// Get get a connection resource from the pool
func (r *RedisPoolResource) Get() (RedisConn, error) {
	if r.pool.IsClosed() {
		r.dial()
	}

	ctx := context.TODO()
	resource, err := r.pool.Get(ctx)

	if err != nil {
		return RedisConn{}, err
	}

	rc := resource.(RedisConn)

	if err = rc.Err(); err != nil {
		r.pool.Put(rc)

		return rc, err
	}

	return rc, nil
}

// Put return a connection resource to the pool
func (r *RedisPoolResource) Put(rc RedisConn) {
	r.pool.Put(rc)
}

// ScanJSON scans json string to the struct or struct slice pointed to by dest
func ScanJSON(reply interface{}, dest interface{}) error {
	v := reflect.Indirect(reflect.ValueOf(dest))

	var err error

	switch v.Kind() {
	case reflect.Struct:
		err = scanJSONObj(reply, dest)
	case reflect.Slice:
		err = scanJSONSlice(reply, dest)
	}

	return err
}

func scanJSONObj(reply interface{}, dest interface{}) error {
	bytes, err := redis.Bytes(reply, nil)

	if err != nil {
		return err
	}

	err = json.Unmarshal(bytes, dest)

	if err != nil {
		return err
	}

	return nil
}

func scanJSONSlice(reply interface{}, dest interface{}) error {
	bytes, err := redis.ByteSlices(reply, nil)

	if err != nil {
		return err
	}

	if len(bytes) == 0 {
		return nil
	}

	v := reflect.Indirect(reflect.ValueOf(dest))

	if v.Kind() != reflect.Slice {
		return errors.New("the dest must be a slice")
	}

	t := v.Type()
	v.Set(reflect.MakeSlice(t, 0, 0))

	for _, b := range bytes {
		elem := reflect.New(t.Elem()).Elem()
		err := json.Unmarshal(b, elem.Addr().Interface())

		if err != nil {
			return err
		}

		v.Set(reflect.Append(v, elem))
	}

	return nil
}
